Team Members
Edgar Robitaille (erobita1)
- Implemented commands C, T, P, S, K, V, and Q. Added user manual play, function testing, and puzzle.c/h.  
Patrick Hwang (phwang7)
- Implemented commands I and W. Worked on valgrind debugging and error handling. 

Implementation Notes:
- One interesting thing about our project is that we used a 2D array for the image instead of a 1D array. While most groups that we talked to were using a 1D array, we thought using a 2D array would allow for more easy visualization of the image. Note that the zero tile represents the empty space while the -1 value was used to initialize the puzzle. The puzzle commands are pretty standard. puzzle_create is used to first create the new puzzle, puzzle_destroy frees the memory and gets rid of the puzzle entirely. There is puzzle_get_tile and puzzle_set_tile, the 'setters and getters' of the value of a certain tile at a certain point in the grid. Finally, another function puzzle_zero_tile was used to always know where the location of the zero or moveable tile was throughout the game, which made it much easier to implement the S command in handle_S_command. 
- Other miscellaneous functions include opposite_direction, which was used in the manhattan distance (calculation denoted by the manhattan_distance function) implementation of the handle_V_command in order to improve the efficiency of the algorithm. The function checks for the opposite direction and was used to make sure the algorithm did not waste time checking if a move backward from the previous move is worth checking to solve the puzzle. The puzzle_copy function was also included in this implementation just as the pseudocode requested; this function simply creates a copy of the current puzzle instance.
Command Specific Notes:
- handle_C_command is first used to set the size of the puzzle. The C command should always be the first command in line and should be formatted as follows: C (puzzle size n), where the overall puzzle size is n x n. This part of the code creates the initial puzzle and uses the size specified by the user. The puzzle has a minimum size of 2 and a maximum size of 20, inclusive. 
- handle_T_command is used to set the initial configuration of the puzzle and utilizes the puzzle_set_tile function to do so. The user would call the command in the following format: T (puzzle config), where there are a single space between each puzzle block. This function also checks that the puzzle configuration is valid and sets up the puzzle accordingly.
- handle_I_command is used to initialize the background image of the puzzle. This is later passed into handle_W_command but first loads the background image from PPM image file. This function originally had many valgrind memory leaks, but this was eventually fixed by adding a check that the puzzle pointer was not null before destroying the puzzle in puzzle_destroy function. 
- move_tile is used as a helper function for the handle_S_command function. This was found to be much easier than doing everything inside of the handle_S_command itself and made it more organized as well. Simply put, the move_tile function moves the tile in the specified direction by the user: 'u', 'd', 'l', 'r', which indicate up, down, left, right, respectively. If the user does not input one of these four directions it results in an invalid input error catch. From here, the move_tile function updates the puzzle accordingly while the handle_S_command essentially verifies that the move was valid and makes sense in the context of the puzzle. The handle_S_command was very much a hassle and originally when the function started to work, we realized that the entire matrix was transposed. While we thought this was okay at first, it caused major issues in the implementation of the V command, and resulted in many "Puzzle cannot be moved in specified direction" errors as the puzzle was trying to be moved in a transposed direction, many of times which resulted in the zero tile being moved into the wall (an invalid move). Eventually, this issue was fixed and the handle_V_command did work as expected. 
- handle_P_command is quite simple. It iterates through the entire puzzle 2D array and prints out the current puzzle configuration (at the time of the call) in a single line, as indicated on the course website. 
- handle_W_command takes a puzzle and input file/output file name, and utilizes the handle_I_command to create an image of the puzzle with the specified background image and writes the puzzle configuration to a file. It first checks that the dimensions of the background image are evenly divisible by the puzzle dimensions and that the dimensions are valid. Then it creates a new instance of an Image struct and iterates through the puzzle grid and background image data to create a new image with the puzzle pieces as specified. It sets black pixels for the empty tile and copies the corresponding part of the background image to the other tile spots. Then it writes the output image to a file with WritePPM and writes the puzzle configuration to a file. Then it frees memory of output image to avoid any valgrind or memory leakages. This was definitely the hardest function to implement and took the longest to understand.
- handle_K_command takes the current configuration of the puzzle and prints returns whether or not the puzzle is currently solved. Note that there is a variable "output" that decides whether or not the program actually prints out "Solved" or "Not solved", as some parts of the program did not want these words to be printed out while calling handle_K_command. Essentially, this function checks whether or not the entire puzzle configuration is in numerical order except for the last character, and makes sure the final character is zero. If this is the case, it will output "Solved", else "Not solved". 
- solve_puzzle is a helper function used for handle_V_command which recursively calls itself until the puzzle is solved and returns the steps which resulted in the solved puzzle configuration. handle_V_command iterates through the array and prints out each step with an S in the beginning then the direction that resulted in the solved configuration. These functions utilize the handle_K_command to check if the current puzzle configuration is in its solved order or not. One interesting thing about our implementation is that originally, the program did not work for the base or initial configuration (ie the original config would result in "No solution" no matter what). It would only work after a single S command was called. To account for this, there is a set of if statements which kind of "trick" the program into thinking the S command has been called already to make it work for the initial case. These if statements simply check if it is possible for the zero tile to moved in a certain direction, then it instantly undoes this movement, bringing the configuration back to the initial state, which allows the program to correctly solve recursively for some reason. While this may not be the most efficient way to make the handle_V_command to work, we found it to be the most convenient and not too much of a hassle to include and it should work for all test cases.
- handle_Q_command simply quits the program and destroys the puzzle to avoid any memory leakages or valgrind issues. 